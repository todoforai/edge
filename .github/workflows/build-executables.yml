name: Build and Deploy Tauri Applications

on:
  push:
    branches: [ prod ]
    tags:   [ 'v*' ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: ubuntu-22.04
            target_triple: x86_64-unknown-linux-gnu
            bundle_type: deb
          - os: ubuntu-latest
            target_triple: x86_64-unknown-linux-gnu
            bundle_type: appimage
          - os: windows-latest
            target_triple: x86_64-pc-windows-msvc
            bundle_type: msi
          - os: macos-14
            target_triple: aarch64-apple-darwin
            bundle_type: dmg
          - os: macos-13
            target_triple: x86_64-apple-darwin
            bundle_type: dmg

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .
        pip install PyInstaller>=5.0
        # Only install build on ubuntu-22.04 for Python distribution
        if [ "${{ matrix.os }}" = "ubuntu-22.04" ]; then
          pip install build
        fi
      shell: bash

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: 'edge_frontend/package.json'
    
    - name: Fresh Node install for this runner
      run: |
        cd edge_frontend
        rm -rf node_modules package-lock.json
        npm install --no-audit --progress=false
      shell: bash

    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        profile: minimal
        override: true

    - name: Install Node dependencies
      run: |
        cd edge_frontend
        npm install --no-audit --progress=false
        npm install -g @tauri-apps/cli
      shell: bash

    - name: Install Tauri dependencies (Ubuntu)
      if: contains(matrix.os, 'ubuntu')
      run: |
        sudo apt-get update
        sudo apt-get install -y libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          libssl-dev \
          libgtk-3-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev \
          libglib2.0-dev \
          pkg-config \
          patchelf \
          libjavascriptcoregtk-4.1-dev \
          libsoup-3.0-dev \
          xdg-utils \
          file \
          desktop-file-utils \
          libfuse2 \
          squashfs-tools
      shell: bash

    - name: Build sidecar executable
      run: make build-sidecar
      shell: bash

    - name: Install Windows SDK (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        Write-Host "Installing Windows SDK..."
        choco install windows-sdk-10-version-2004-all -y
      shell: powershell

    - name: Sign sidecar executable
      if: matrix.os == 'windows-latest'
      continue-on-error: true
      id: sign-sidecar
      run: |
        if (Test-Path "dist/todoforai-edge-sidecar.exe") {
          Write-Host "Signing sidecar executable using remote service..."
          $originalPath = "dist/todoforai-edge-sidecar.exe"
          $signedPath = "dist/todoforai-edge-sidecar.signed.exe"
          
          $originalSize = (Get-Item $originalPath).Length
          Write-Host "Original sidecar size: $($originalSize / 1MB) MB"
          
          Write-Host "Checking signing service availability..."
          & curl.exe -f -s -H "Authorization: Bearer $env:SIGNING_API_KEY" "$env:SIGNING_SERVICE_URL/status" -o "service_status.json"
          
          if ($LASTEXITCODE -eq 0 -and (Test-Path "service_status.json")) {
            Write-Host "‚úÖ Signing service is available"
            Remove-Item "service_status.json" -ErrorAction SilentlyContinue
            
            & curl.exe -f -X POST -H "Authorization: Bearer $env:SIGNING_API_KEY" -F "file=@$originalPath" "$env:SIGNING_SERVICE_URL/sign" -o $signedPath
            
            if ($LASTEXITCODE -eq 0 -and (Test-Path $signedPath)) {
              $signedSize = (Get-Item $signedPath).Length
              Write-Host "Downloaded signed file size: $($signedSize / 1MB) MB"
              
              if ($signedSize -gt ($originalSize * 0.95) -and $signedSize -lt ($originalSize * 1.5)) {
                $fileHeader = [System.IO.File]::ReadAllBytes($signedPath)[0..1]
                if ($fileHeader[0] -eq 0x4D -and $fileHeader[1] -eq 0x5A) {
                  Move-Item $signedPath $originalPath -Force
                  Write-Host "‚úÖ Successfully signed sidecar executable"
                  echo "SIDECAR_SIGNED=true" >> $env:GITHUB_OUTPUT
                  
                  $sig = Get-AuthenticodeSignature $originalPath
                  Write-Host "Signature Status: $($sig.Status)"
                  if ($sig.Status -eq "Valid") {
                    Write-Host "‚úÖ Sidecar signature is valid" -ForegroundColor Green
                  } else {
                    Write-Warning "‚ö†Ô∏è Sidecar signature status: $($sig.Status)"
                  }
                } else {
                  Write-Warning "‚ö†Ô∏è Signed file is not a valid executable (wrong header)"
                  Remove-Item $signedPath -ErrorAction SilentlyContinue
                  echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
                }
              } else {
                Write-Warning "‚ö†Ô∏è Signed file size suspicious ($signedSize vs $originalSize bytes) - likely an error response"
                Remove-Item $signedPath -ErrorAction SilentlyContinue
                echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
              }
            } else {
              Write-Warning "‚ö†Ô∏è curl failed (exit code: $LASTEXITCODE) or signed file not created"
              echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
            }
          } else {
            Write-Warning "‚ö†Ô∏è Signing service unavailable (exit code: $LASTEXITCODE)"
            Remove-Item "service_status.json" -ErrorAction SilentlyContinue
            echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
          }
          
          if (Test-Path $signedPath) {
            Remove-Item $signedPath -ErrorAction SilentlyContinue
          }
          
        } else {
          Write-Warning "Sidecar executable not found at dist/todoforai-edge-sidecar.exe"
          echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
        }
      env:
        SIGNING_SERVICE_URL: ${{ secrets.SIGNING_SERVICE_URL }}
        SIGNING_API_KEY: ${{ secrets.SIGNING_API_KEY }}
      shell: powershell

    - name: Prepare sidecar for Tauri
      run: make copy-sidecar
      shell: bash

    - name: Verify sidecar placement
      run: |
        echo "Checking for sidecar executable..."
        ls -la edge_frontend/src-tauri/binaries/ || echo "Binaries directory not found"
        find edge_frontend/src-tauri/binaries/ -name "*sidecar*" -type f || echo "No sidecar files found"
      shell: bash

    - name: Write entitlements (macOS)
      if: startsWith(matrix.os, 'macos')
      run: |
        cat > edge_frontend/src-tauri/entitlements.plist <<'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>com.apple.security.cs.disable-library-validation</key>
          <true/>
        </dict>
        </plist>
        EOF
        cat edge_frontend/src-tauri/entitlements.plist

    - name: Import Code‚ÄëSigning Certificates (macOS)
      if: startsWith(matrix.os, 'macos')
      uses: apple-actions/import-codesign-certs@v2
      with:
        p12-file-base64:      ${{ secrets.APPLE_CERTIFICATE }}
        p12-password:         ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        keychain-password:    ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

    - name: Verify Developer ID certificate (macOS)
      id: dev-id
      if: startsWith(matrix.os, 'macos')
      run: |
        echo "::group::Available certificates"
        security find-identity -v -p codesigning
        echo "::endgroup::"
        
        SHA=$(security find-identity -v -p codesigning | 
              grep "Developer ID Application:" | 
              head -1 | 
              awk '{print $2}')
        
        if [ -z "$SHA" ]; then
          echo "::error::Developer ID Application certificate not found in keychain"
          echo "Make sure you've exported the correct certificate from Keychain Access"
          echo "and updated the APPLE_CERTIFICATE secret with its base64 content."
          exit 1
        fi
        
        echo "SHA=$SHA" >> $GITHUB_OUTPUT
        echo "Found Developer ID Application certificate: $SHA"
        
        CERT_NAME=$(security find-identity -v -p codesigning | 
                   grep "$SHA" | 
                   sed -E 's/.*"([^"]+)".*/\1/')
        echo "CERT_NAME=$CERT_NAME" >> $GITHUB_OUTPUT
        echo "Certificate name: $CERT_NAME"

    # Build specific bundle types per platform
    - name: Build Tauri application (DEB)
      if: matrix.bundle_type == 'deb'
      run: |
        cd edge_frontend
        npm run tauri build -- --bundles deb
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
      shell: bash

    - name: Build Tauri application (AppImage)
      if: matrix.bundle_type == 'appimage'
      run: |
        cd edge_frontend
        npm run tauri build -- --bundles appimage
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
      shell: bash

    - name: Build Tauri application (MSI)
      if: matrix.bundle_type == 'msi'
      run: |
        cd edge_frontend
        npm run tauri build -- --bundles msi
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
      shell: bash

    - name: Build Tauri application (DMG)
      if: matrix.bundle_type == 'dmg'
      run: |
        cd edge_frontend
        npm run tauri build -- --bundles dmg,app
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
        APPLE_SIGNING_IDENTITY: ${{ steps.dev-id.outputs.CERT_NAME }}
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
      shell: bash

    - name: Build Python distribution
      if: matrix.os == 'ubuntu-22.04'
      run: |
        rm -f dist/todoforai-edge-sidecar*
        python -m build --wheel --sdist
      shell: bash

    - name: Sign MSI installer
      if: matrix.os == 'windows-latest'
      continue-on-error: true
      id: sign-msi
      run: |
        $msiPath = Get-ChildItem -Path "edge_frontend/src-tauri/target/release/bundle/msi" -Filter "*.msi" | Select-Object -First 1 -ExpandProperty FullName
        if ($msiPath) {
          $originalSize = (Get-Item "$msiPath").Length
          $signedMsiPath = [System.IO.Path]::ChangeExtension($msiPath, ".signed.msi")
          Write-Host "Signing MSI installer: $msiPath ($(($originalSize / 1MB).ToString('F1')) MB)"
          
          & curl.exe -f -X POST -H "Authorization: Bearer $env:SIGNING_API_KEY" -F "file=@$msiPath" "$env:SIGNING_SERVICE_URL/sign" -o "$signedMsiPath"
          
          if ($LASTEXITCODE -eq 0 -and (Test-Path "$signedMsiPath")) {
            $signedSize = (Get-Item "$signedMsiPath").Length
            Write-Host "Downloaded signed MSI size: $(($signedSize / 1MB).ToString('F1')) MB"
            
            if ($signedSize -gt ($originalSize * 0.9)) {
              Move-Item "$signedMsiPath" "$msiPath" -Force
              Write-Host "‚úÖ Successfully signed MSI installer"
              echo "MSI_SIGNED=true" >> $GITHUB_OUTPUT
            } else {
              Write-Warning "‚ö†Ô∏è Signed MSI too small - likely an error response"
              Remove-Item "$signedMsiPath" -ErrorAction SilentlyContinue
              echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
            }
          } else {
            Write-Warning "‚ö†Ô∏è MSI signing failed (curl exit code: $LASTEXITCODE)"
            echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
          }
        } else {
          Write-Warning "MSI installer not found"
          echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
        fi
      env:
        SIGNING_SERVICE_URL: ${{ secrets.SIGNING_SERVICE_URL }}
        SIGNING_API_KEY: ${{ secrets.SIGNING_API_KEY }}
      shell: powershell

    - name: Install jq (macOS)
      if: startsWith(matrix.os, 'macos')
      run: brew install jq
      shell: bash

    - name: Manual Notarize & staple macOS app
      if: startsWith(matrix.os, 'macos') && !contains(env.TAURI_BUILD_LOG, 'notarization complete')
      run: |
        echo "Creating notarization keychain profile"
        xcrun notarytool store-credentials "notary-profile" \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --team-id "${{ secrets.APPLE_TEAM_ID }}" \
          --password "${{ secrets.APPLE_APP_PASSWORD }}"
        
        DMG_PATH=$(find edge_frontend/src-tauri/target/release/bundle/dmg -name "*.dmg" | head -n 1)
        if [ -z "$DMG_PATH" ]; then
          echo "::error::DMG file not found"
          exit 1
        fi
        echo "Found DMG at: $DMG_PATH"
        
        echo "Submitting for notarization..."
        SUBMISSION_JSON=$(xcrun notarytool submit "$DMG_PATH" \
          --keychain-profile "notary-profile" \
          --wait \
          --output-format json)
        
        echo "Notarization submission output:"
        echo "$SUBMISSION_JSON"
        
        SUBMISSION_ID=$(echo "$SUBMISSION_JSON" | jq -r '.id')
        STATUS=$(echo "$SUBMISSION_JSON" | jq -r '.status')
        
        echo "Notarization submission ID: $SUBMISSION_ID"
        echo "Notarization status: $STATUS"
        
        if [ "$STATUS" != "Accepted" ]; then
          echo "::error::Notarization failed with status: $STATUS"
          
          echo "Fetching detailed notarization log..."
          xcrun notarytool log "$SUBMISSION_ID" \
            --keychain-profile "notary-profile" > notarization.log
          
          echo "::group::Notarization Log"
          cat notarization.log
          echo "::endgroup::"
          
          exit 1
        fi
        
        echo "Stapling notarization ticket..."
        xcrun stapler staple "$DMG_PATH"
        
        xcrun stapler validate "$DMG_PATH"
      shell: bash

    - name: Set Tauri bundle path
      id: bundle-path
      run: |
        echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle" >> $GITHUB_OUTPUT
      shell: bash

    - name: Upload Tauri application bundle
      uses: actions/upload-artifact@v4
      with:
        name: todoforai-edge-${{ matrix.target_triple }}-${{ matrix.bundle_type }}
        path: ${{ steps.bundle-path.outputs.BUNDLE_PATH }}

    - name: Upload Python distribution
      if: matrix.os == 'ubuntu-22.04'
      uses: actions/upload-artifact@v4
      with:
        name: todoforai-edge-python-dist
        path: dist/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/prod'

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4

    - name: Debug environment
      run: |
        if [ -n "${{ secrets.R2_BUCKET_NAME }}" ]; then
          echo "R2_BUCKET_NAME is set"
        else
          echo "R2_BUCKET_NAME is NOT set"
        fi
        if [ -n "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
          echo "CLOUDFLARE_API_TOKEN is set"
        else
          echo "CLOUDFLARE_API_TOKEN is NOT set"
        fi
        if [ -n "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]; then
          echo "CLOUDFLARE_ACCOUNT_ID is set"
        else
          echo "CLOUDFLARE_ACCOUNT_ID is NOT set"
        fi
        
        echo "::group::Artifacts"
        ls -R
        echo "::endgroup::"

    - name: Install Cloudflare Wrangler
      run: npm install -g wrangler

    - name: Upload to Cloudflare R2 using Wrangler
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        R2_BUCKET_NAME:       ${{ secrets.R2_BUCKET_NAME }}
      run: |
        if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}; FOLDER="$VERSION"
        else
          FOLDER="latest"
        fi
        echo "Uploading to folder: $FOLDER"
        
        upload_with_retry() {
          local file="$1"
          local remote_path="$2"
          local max_retries=3
          local retry_count=0
          
          while [ $retry_count -lt $max_retries ]; do
            echo "Uploading $file to $remote_path (attempt $((retry_count + 1))/$max_retries)"
            
            if cat "$file" | wrangler r2 object put "$remote_path" --pipe --content-type application/octet-stream --remote; then
              echo "‚úÖ Successfully uploaded $file"
              return 0
            else
              retry_count=$((retry_count + 1))
              if [ $retry_count -lt $max_retries ]; then
                echo "‚ùå Upload failed, retrying in 10 seconds..."
                sleep 10
              else
                echo "‚ùå Upload failed after $max_retries attempts: $file"
                return 1
              fi
            fi
          done
        }

        mkdir -p uploads
        
        if [ -d "todoforai-edge-python-dist" ]; then
          echo "Processing Python distribution artifacts..."
          find todoforai-edge-python-dist -name "*.whl" -exec cp {} uploads/ \;
          find todoforai-edge-python-dist -name "*.tar.gz" -exec cp {} uploads/ \;
          
          for FILE in uploads/*.whl uploads/*.tar.gz; do
            if [ -f "$FILE" ]; then
              FILENAME=$(basename "$FILE")
              upload_with_retry "$FILE" "$R2_BUCKET_NAME/edge/$FOLDER/$FILENAME"
            fi
          done
        fi
        
        for DIR in todoforai-edge-*; do
          if [ -d "$DIR" ] && [ "$DIR" != "todoforai-edge-python-dist" ]; then
            TARGET_TRIPLE=$(echo $DIR | sed 's/todoforai-edge-//')
            
            if [[ "$TARGET_TRIPLE" == *windows* ]]; then
              PLATFORM="windows"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              find "$DIR" -name "*.msi" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" \;
              
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" ]; then
                upload_with_retry "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.msi"
              fi
            elif [[ "$TARGET_TRIPLE" == *linux* ]]; then
              PLATFORM="linux"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              find "$DIR" -name "*.AppImage" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" \;
              find "$DIR" -name "*.deb" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" \;
              
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" ]; then
                upload_with_retry "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.AppImage"
              fi
              
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" ]; then
                echo "üì¶ DEB file size: $(du -h "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" | cut -f1)"
                upload_with_retry "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.deb"
              fi
            elif [[ "$TARGET_TRIPLE" == *darwin* || "$TARGET_TRIPLE" == *apple* ]]; then
              PLATFORM="macos"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              find "$DIR" -name "*.dmg" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" \;
              
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" ]; then
                upload_with_retry "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.dmg"
              fi
            fi
          fi
        done
        
        if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
          echo "üîÑ Copying files to latest folder..."
          for FILE in uploads/*; do
            if [ -f "$FILE" ]; then
              FILENAME=$(basename "$FILE")
              upload_with_retry "$FILE" "$R2_BUCKET_NAME/edge/latest/$FILENAME"
            fi
          done
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      if: startsWith(github.ref, 'refs/tags/v')
      with:
        files: uploads/*

  deploy-pypi:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/prod'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Download Python distribution artifacts
      uses: actions/download-artifact@v4
      with:
        name: todoforai-edge-python-dist
        path: dist/
    
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_API_TOKEN }}
        verbose: true
