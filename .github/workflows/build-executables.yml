name: Build and Deploy Tauri Applications

on:
  push:
    branches: [ prod ]
    tags:   [ 'v*' ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target_triple: x86_64-unknown-linux-gnu
          - os: windows-latest
            target_triple: x86_64-pc-windows-msvc
          - os: macos-14
            target_triple: aarch64-apple-darwin
          - os: macos-13
            target_triple: x86_64-apple-darwin

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        # Skip Node install that make install does locally
        pip install -e .
      shell: bash

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'
        cache-dependency-path: 'edge_frontend/package.json'
    
    # Fresh install for the current platform to ensure platform-specific binaries are available
    - name: Fresh Node install for this runner
      run: |
        cd edge_frontend
        rm -rf node_modules package-lock.json   # Delete BOTH to ensure clean install
        npm install --no-audit --progress=false
      shell: bash

    - name: Set up Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        profile: minimal
        override: true

    # Install Node dependencies and Tauri CLI
    - name: Install Node dependencies
      run: |
        cd edge_frontend
        npm install --no-audit --progress=false
        # Install Tauri CLI globally to avoid platform-specific module issues
        npm install -g @tauri-apps/cli
      shell: bash

    - name: Install Tauri dependencies (Ubuntu)
      if: matrix.os == 'ubuntu-latest'
      run: |
        sudo apt-get update
        sudo apt-get install -y libwebkit2gtk-4.1-dev \
          build-essential \
          curl \
          wget \
          libssl-dev \
          libgtk-3-dev \
          libayatana-appindicator3-dev \
          librsvg2-dev
      shell: bash

    - name: Build sidecar executable
      run: make build-sidecar
      shell: bash

    # Prepare sidecar for Tauri with correct target triple
    - name: Prepare sidecar for Tauri
      run: |
        # Create binaries directory
        mkdir -p edge_frontend/src-tauri/binaries
        
        # Determine source and target names based on OS
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          SOURCE_NAME="todoforai-edge-sidecar.exe"
          TARGET_NAME="todoforai-edge-sidecar-${{ matrix.target_triple }}.exe"
        else
          SOURCE_NAME="todoforai-edge-sidecar"
          TARGET_NAME="todoforai-edge-sidecar-${{ matrix.target_triple }}"
        fi
        
        # Copy the executable with the correct target triple
        cp dist/$SOURCE_NAME edge_frontend/src-tauri/binaries/$TARGET_NAME
        
        # Make it executable on Unix-like systems
        if [ "${{ matrix.os }}" != "windows-latest" ]; then
          chmod +x edge_frontend/src-tauri/binaries/$TARGET_NAME
        fi

        echo "Sidecar prepared at: edge_frontend/src-tauri/binaries/$TARGET_NAME"
      shell: bash

    # ─── 🍏 Create simplified entitlements file for macOS ─────────────────────
    - name: Write entitlements (macOS)
      if: startsWith(matrix.os, 'macos')
      run: |
        cat > edge_frontend/src-tauri/entitlements.plist <<'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>com.apple.security.cs.disable-library-validation</key>
          <true/>
        </dict>
        </plist>
        EOF
        cat edge_frontend/src-tauri/entitlements.plist

    # ─── 🍏 1. Import the certificate ───────────────────────────────────────
    - name: Import Code‑Signing Certificates (macOS)
      if: startsWith(matrix.os, 'macos')
      uses: apple-actions/import-codesign-certs@v2
      with:
        p12-file-base64:      ${{ secrets.APPLE_CERTIFICATE }}
        p12-password:         ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        keychain-password:    ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}  # Use same password for keychain

    # ─── 🍏 2. Verify Developer ID certificate is present ─────────────────────
    - name: Verify Developer ID certificate (macOS)
      id: dev-id
      if: startsWith(matrix.os, 'macos')
      run: |
        echo "::group::Available certificates"
        security find-identity -v -p codesigning
        echo "::endgroup::"
        
        # Look for Developer ID Application certificate without team ID filtering
        SHA=$(security find-identity -v -p codesigning | 
              grep "Developer ID Application:" | 
              head -1 | 
              awk '{print $2}')
        
        if [ -z "$SHA" ]; then
          echo "::error::Developer ID Application certificate not found in keychain"
          echo "Make sure you've exported the correct certificate from Keychain Access"
          echo "and updated the APPLE_CERTIFICATE secret with its base64 content."
          exit 1
        fi
        
        echo "SHA=$SHA" >> $GITHUB_OUTPUT
        echo "Found Developer ID Application certificate: $SHA"
        
        # Get the full name of the certificate for Tauri config
        CERT_NAME=$(security find-identity -v -p codesigning | 
                   grep "$SHA" | 
                   sed -E 's/.*"([^"]+)".*/\1/')
        echo "CERT_NAME=$CERT_NAME" >> $GITHUB_OUTPUT
        echo "Certificate name: $CERT_NAME"


    # Build the Tauri application
    - name: Build Tauri application
      run: make tauri-build
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
        APPLE_SIGNING_IDENTITY: ${{ steps.dev-id.outputs.CERT_NAME }}
        # Let Tauri handle notarization
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
      shell: bash

    # Notarize and staple the macOS application using manual commands
    # Only run this if Tauri's built-in notarization fails
    - name: Manual Notarize & staple macOS app
      if: startsWith(matrix.os, 'macos') && !contains(env.TAURI_BUILD_LOG, 'notarization complete')
      run: |
        # Create keychain profile for notarization
        echo "Creating notarization keychain profile"
        xcrun notarytool store-credentials "notary-profile" \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --team-id "${{ secrets.APPLE_TEAM_ID }}" \
          --password "${{ secrets.APPLE_APP_PASSWORD }}"
        
        # Find the DMG file
        DMG_PATH=$(find edge_frontend/src-tauri/target/release/bundle/dmg -name "*.dmg" | head -n 1)
        if [ -z "$DMG_PATH" ]; then
          echo "::error::DMG file not found"
          exit 1
        fi
        echo "Found DMG at: $DMG_PATH"
        
        # Submit for notarization and capture the submission ID using JSON output
        echo "Submitting for notarization..."
        SUBMISSION_JSON=$(xcrun notarytool submit "$DMG_PATH" \
          --keychain-profile "notary-profile" \
          --wait \
          --output-format json)
        
        echo "Notarization submission output:"
        echo "$SUBMISSION_JSON"
        
        # Extract the submission ID and status using jq
        SUBMISSION_ID=$(echo "$SUBMISSION_JSON" | jq -r '.id')
        STATUS=$(echo "$SUBMISSION_JSON" | jq -r '.status')
        
        echo "Notarization submission ID: $SUBMISSION_ID"
        echo "Notarization status: $STATUS"
        
        # Check if notarization was successful
        if [ "$STATUS" != "Accepted" ]; then
          echo "::error::Notarization failed with status: $STATUS"
          
          # Get detailed log for the submission
          echo "Fetching detailed notarization log..."
          xcrun notarytool log "$SUBMISSION_ID" \
            --keychain-profile "notary-profile" > notarization.log
          
          echo "::group::Notarization Log"
          cat notarization.log
          echo "::endgroup::"
          
          exit 1
        fi
        
        # Staple the notarization ticket to the DMG
        echo "Stapling notarization ticket..."
        xcrun stapler staple "$DMG_PATH"
        
        # Verify the stapling
        xcrun stapler validate "$DMG_PATH"
      shell: bash

    # Determine the Tauri app bundle path based on OS
    - name: Set Tauri bundle path
      id: bundle-path
      run: |
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle/msi" >> $GITHUB_OUTPUT
          echo "BUNDLE_EXTENSION=msi" >> $GITHUB_OUTPUT
        elif [ "${{ matrix.os }}" = "ubuntu-latest" ]; then
          # For Linux, we'll collect both AppImage and DEB
          echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle" >> $GITHUB_OUTPUT
          echo "BUNDLE_EXTENSION=*" >> $GITHUB_OUTPUT
        else
          # For macOS, we'll collect both .app and .dmg
          echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle" >> $GITHUB_OUTPUT
          echo "BUNDLE_EXTENSION=*" >> $GITHUB_OUTPUT
        fi
      shell: bash

    # Upload the Tauri application bundle as an artifact
    - name: Upload Tauri application bundle
      uses: actions/upload-artifact@v4
      with:
        name: todoforai-edge-${{ matrix.target_triple }}
        path: ${{ steps.bundle-path.outputs.BUNDLE_PATH }}

  # ─────────────────────────── Deployment ───────────────────────────
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/prod'

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4

    - name: Debug environment
      run: |
        # Check if secrets are available (without revealing them)
        if [ -n "${{ secrets.R2_BUCKET_NAME }}" ]; then
          echo "R2_BUCKET_NAME is set"
        else
          echo "R2_BUCKET_NAME is NOT set"
        fi
        if [ -n "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
          echo "CLOUDFLARE_API_TOKEN is set"
        else
          echo "CLOUDFLARE_API_TOKEN is NOT set"
        fi
        if [ -n "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}" ]; then
          echo "CLOUDFLARE_ACCOUNT_ID is set"
        else
          echo "CLOUDFLARE_ACCOUNT_ID is NOT set"
        fi
        
        echo "::group::Artifacts"
        ls -R
        echo "::endgroup::"

    - name: Install Cloudflare Wrangler
      run: npm install -g wrangler

    - name: Upload to Cloudflare R2 using Wrangler
      env:
        CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        R2_BUCKET_NAME:       ${{ secrets.R2_BUCKET_NAME }}
      run: |
        if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}; FOLDER="$VERSION"
        else
          FOLDER="latest"
        fi
        echo "Uploading to folder: $FOLDER"
        
        # Create a directory for each platform's artifacts
        mkdir -p uploads
        
        # Find and prepare all Tauri app bundles for upload
        for DIR in todoforai-edge-*; do
          if [ -d "$DIR" ]; then
            TARGET_TRIPLE=$(echo $DIR | sed 's/todoforai-edge-//')
            
            # Map target triple to user-friendly platform name
            if [[ "$TARGET_TRIPLE" == *windows* ]]; then
              PLATFORM="windows"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              # For Windows, find and copy the MSI installer
              find "$DIR" -name "*.msi" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" \;
              
              # Upload the MSI
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" ]; then
                wrangler r2 object put "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.msi" \
                  --file "uploads/todoforai-edge-${PLATFORM}-${ARCH}.msi" \
                  --content-type application/octet-stream \
                  --remote
              fi
            elif [[ "$TARGET_TRIPLE" == *linux* ]]; then
              PLATFORM="linux"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              # For Linux, find and copy both AppImage and DEB
              find "$DIR" -name "*.AppImage" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" \;
              find "$DIR" -name "*.deb" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" \;
              
              # Upload the AppImage
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" ]; then
                wrangler r2 object put "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" \
                  --file "uploads/todoforai-edge-${PLATFORM}-${ARCH}.AppImage" \
                  --content-type application/octet-stream \
                  --remote
              fi
              
              # Upload the DEB
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" ]; then
                wrangler r2 object put "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.deb" \
                  --file "uploads/todoforai-edge-${PLATFORM}-${ARCH}.deb" \
                  --content-type application/octet-stream \
                  --remote
              fi
            elif [[ "$TARGET_TRIPLE" == *darwin* || "$TARGET_TRIPLE" == *apple* ]]; then
              PLATFORM="macos"
              ARCH="x64"
              if [[ "$TARGET_TRIPLE" == *aarch64* ]]; then
                ARCH="arm64"
              fi
              
              # For macOS, prioritize DMG installer
              find "$DIR" -name "*.dmg" -exec cp {} "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" \;
              
              # Upload the DMG if found
              if [ -f "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" ]; then
                wrangler r2 object put "$R2_BUCKET_NAME/edge/$FOLDER/todoforai-edge-${PLATFORM}-${ARCH}.dmg" \
                  --file "uploads/todoforai-edge-${PLATFORM}-${ARCH}.dmg" \
                  --content-type application/octet-stream \
                  --remote
              fi
            fi
          fi
        done
        
        # If this is a tag release, also copy to latest
        if [[ "$GITHUB_REF" == refs/tags/v* ]]; then
          for FILE in uploads/*; do
            if [ -f "$FILE" ]; then
              FILENAME=$(basename "$FILE")
              wrangler r2 object put "$R2_BUCKET_NAME/edge/latest/$FILENAME" \
                --file "$FILE" \
                --content-type application/octet-stream \
                --remote
            fi
          done
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      if: startsWith(github.ref, 'refs/tags/v')
      with:
        files: uploads/*
