name: Build and Deploy Tauri Applications

on:
  push:
    branches: [ prod ]
    tags:   [ 'v*' ]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  build:
    strategy:
      fail-fast: true  # Stop all matrix jobs if any fails
      matrix:
        include:
          - os: windows-latest
            target_triple: x86_64-pc-windows-msvc
            container: null
          - os: macos-14
            target_triple: aarch64-apple-darwin
            container: null
          - os: macos-13
            target_triple: x86_64-apple-darwin
            container: null
          - os: ubuntu-latest
            target_triple: x86_64-unknown-linux-gnu
            container: ubuntu:20.04
          - os: ubuntu-latest
            target_triple: x86_64-unknown-linux-musl
            container: ubuntu:20.04

    runs-on: ${{ matrix.os }}
    container: ${{ matrix.container }}

    steps:
    - uses: actions/checkout@v4

    # Container-specific setup for Linux
    - name: Install base dependencies (container)
      if: matrix.container
      run: |
        set -eu
        apt-get update
        DEBIAN_FRONTEND=noninteractive apt-get install -y \
          curl wget git ca-certificates software-properties-common gnupg build-essential sudo

    - name: Install Python 3.10 (deadsnakes) and pip
      if: matrix.container
      run: |
        set -eu
        add-apt-repository ppa:deadsnakes/ppa -y
        apt-get update
        DEBIAN_FRONTEND=noninteractive apt-get install -y python3.10 python3.10-venv python3.10-dev python3.10-distutils
        # Install pip using get-pip.py with retry and fallback
        for i in {1..3}; do
          if curl -sS https://bootstrap.pypa.io/get-pip.py | python3.10; then
            break
          elif [ $i -eq 3 ]; then
            # Fallback: try installing python3-pip package
            DEBIAN_FRONTEND=noninteractive apt-get install -y python3-pip
            ln -sf /usr/bin/pip3 /usr/local/bin/pip3.10
          else
            echo "Retry $i failed, waiting 5 seconds..."
            sleep 5
          fi
        done
        update-alternatives --install /usr/bin/python python /usr/bin/python3.10 2
        update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.10 2
        # Only set pip alternatives if pip3.10 exists
        if [ -f /usr/local/bin/pip3.10 ]; then
          update-alternatives --install /usr/bin/pip pip /usr/local/bin/pip3.10 2
          update-alternatives --install /usr/bin/pip3 pip3 /usr/local/bin/pip3.10 2
        else
          update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 2
          update-alternatives --install /usr/bin/pip3 pip3 /usr/bin/pip3 2
        fi

    # Standard Python setup for non-container
    - name: Set up Python
      if: '!matrix.container'
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'

    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .
        pip install PyInstaller>=5.0
        if [[ "${{ matrix.container }}" ]]; then
          pip install build
        fi
      shell: bash

    - name: Setup env (Node, Rust, npm)
      uses: ./.github/actions/setup-env
      with:
        target-triple: ${{ matrix.target_triple }}
        node-version: '20'
        frontend-path: edge_frontend
        cache-dependency-path: edge_frontend/package.json
        install-tauri-cli: 'true'

    # Install Tauri dependencies (Ubuntu)
    - name: Install Tauri dependencies (Ubuntu)
      if: contains(matrix.target_triple, 'linux')
      run: |
        if [ "${{ matrix.container }}" ]; then
          # Container environment - use apt-get directly
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y libwebkit2gtk-4.0-dev \
            build-essential \
            curl \
            wget \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev
          # Install musl tools for static linking
          if [[ "${{ matrix.target_triple }}" == *musl* ]]; then
            DEBIAN_FRONTEND=noninteractive apt-get install -y musl-tools
          fi
        else
          # Regular Ubuntu runner - use sudo
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.0-dev \
            build-essential \
            curl \
            wget \
            libssl-dev \
            libgtk-3-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev
          # Install musl tools for static linking
          if [[ "${{ matrix.target_triple }}" == *musl* ]]; then
            sudo apt-get install -y musl-tools
          fi
        fi
      shell: bash

    - name: Build sidecar executable
      run: make build-sidecar
      shell: bash

    # Install Windows SDK for signtool.exe
    - name: Install Windows SDK (Windows)
      if: matrix.os == 'windows-latest'
      run: |
        Write-Host "Installing Windows SDK..."
        choco install windows-sdk-10-version-2004-all -y
      shell: powershell

    # Sign the sidecar executable on Windows using remote signing service
    - name: Sign sidecar executable
      if: matrix.os == 'windows-latest'
      continue-on-error: true
      id: sign-sidecar
      run: |
        if (Test-Path "dist/todoforai-edge-sidecar.exe") {
          Write-Host "Signing sidecar executable using remote service..."
          $originalPath = "dist/todoforai-edge-sidecar.exe"
          $signedPath = "dist/todoforai-edge-sidecar.signed.exe"
          
          $originalSize = (Get-Item $originalPath).Length
          Write-Host "Original sidecar size: $($originalSize / 1MB) MB"
          
          # Check if signing service is available first
          Write-Host "Checking signing service availability..."
          & curl.exe -f -s -H "Authorization: Bearer $env:SIGNING_API_KEY" "$env:SIGNING_SERVICE_URL/status" -o "service_status.json"
          
          if ($LASTEXITCODE -eq 0 -and (Test-Path "service_status.json")) {
            Write-Host "✅ Signing service is available"
            Remove-Item "service_status.json" -ErrorAction SilentlyContinue
            
            # Attempt signing - download to separate file
            & curl.exe -f -X POST -H "Authorization: Bearer $env:SIGNING_API_KEY" -F "file=@$originalPath" "$env:SIGNING_SERVICE_URL/sign" -o $signedPath
            
            if ($LASTEXITCODE -eq 0 -and (Test-Path $signedPath)) {
              $signedSize = (Get-Item $signedPath).Length
              Write-Host "Downloaded signed file size: $($signedSize / 1MB) MB"
              
              # Strict validation: signed file should be similar size or larger
              if ($signedSize -gt ($originalSize * 0.95) -and $signedSize -lt ($originalSize * 1.5)) {
                # Additional validation: check if it's actually an executable
                $fileHeader = [System.IO.File]::ReadAllBytes($signedPath)[0..1]
                if ($fileHeader[0] -eq 0x4D -and $fileHeader[1] -eq 0x5A) {  # "MZ" header
                  # Replace original with signed version
                  Move-Item $signedPath $originalPath -Force
                  Write-Host "✅ Successfully signed sidecar executable"
                  echo "SIDECAR_SIGNED=true" >> $env:GITHUB_OUTPUT
                  
                  # Verify the signature
                  $sig = Get-AuthenticodeSignature $originalPath
                  Write-Host "Signature Status: $($sig.Status)"
                  if ($sig.Status -eq "Valid") {
                    Write-Host "✅ Sidecar signature is valid" -ForegroundColor Green
                  } else {
                    Write-Warning "⚠️ Sidecar signature status: $($sig.Status)"
                  }
                } else {
                  Write-Warning "⚠️ Signed file is not a valid executable (wrong header)"
                  Remove-Item $signedPath -ErrorAction SilentlyContinue
                  echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
                }
              } else {
                Write-Warning "⚠️ Signed file size suspicious ($signedSize vs $originalSize bytes) - likely an error response"
                Remove-Item $signedPath -ErrorAction SilentlyContinue
                echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
              }
            } else {
              Write-Warning "⚠️ curl failed (exit code: $LASTEXITCODE) or signed file not created"
              echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
            }
          } else {
            Write-Warning "⚠️ Signing service unavailable (exit code: $LASTEXITCODE)"
            Remove-Item "service_status.json" -ErrorAction SilentlyContinue
            echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
          }
          
          # Clean up any leftover signed file if validation failed
          if (Test-Path $signedPath) {
            Remove-Item $signedPath -ErrorAction SilentlyContinue
          }
          
        } else {
          Write-Warning "Sidecar executable not found at dist/todoforai-edge-sidecar.exe"
          echo "SIDECAR_SIGNED=false" >> $env:GITHUB_OUTPUT
        }
      env:
        SIGNING_SERVICE_URL: ${{ secrets.SIGNING_SERVICE_URL }}
        SIGNING_API_KEY: ${{ secrets.SIGNING_API_KEY }}
      shell: powershell

    # Prepare sidecar for Tauri with correct target triple
    - name: Prepare sidecar for Tauri
      run: make copy-sidecar
      shell: bash

    # Verify sidecar was copied correctly
    - name: Verify sidecar placement
      run: |
        echo "Checking for sidecar executable..."
        ls -la edge_frontend/src-tauri/binaries/ || echo "Binaries directory not found"
        find edge_frontend/src-tauri/binaries/ -name "*sidecar*" -type f || echo "No sidecar files found"
      shell: bash

    # Ensure jq is available for notarization parsing
    - name: Install jq (macOS)
      if: startsWith(matrix.os, 'macos')
      run: brew install jq
      shell: bash

    # ─── 🍏 Create simplified entitlements file for macOS ─────────────────────
    - name: Write entitlements (macOS)
      if: startsWith(matrix.os, 'macos')
      run: |
        cat > edge_frontend/src-tauri/entitlements.plist <<'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
          <key>com.apple.security.cs.disable-library-validation</key>
          <true/>
        </dict>
        </plist>
        EOF
        cat edge_frontend/src-tauri/entitlements.plist
    # ─── 🍏 1. Import the certificate ───────────────────────────────────────
    - name: Import Code‑Signing Certificates (macOS)
      if: startsWith(matrix.os, 'macos')
      uses: apple-actions/import-codesign-certs@v2
      with:
        p12-file-base64:      ${{ secrets.APPLE_CERTIFICATE }}
        p12-password:         ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        keychain-password:    ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}  # Use same password for keychain

    # ─── 🍏 2. Verify Developer ID certificate is present ─────────────────────
    - name: Verify Developer ID certificate (macOS)
      id: dev-id
      if: startsWith(matrix.os, 'macos')
      run: |
        echo "::group::Available certificates"
        security find-identity -v -p codesigning
        echo "::endgroup::"
        
        # Look for Developer ID Application certificate without team ID filtering
        SHA=$(security find-identity -v -p codesigning | 
              grep "Developer ID Application:" | 
              head -1 | 
              awk '{print $2}')
        
        if [ -z "$SHA" ]; then
          echo "::error::Developer ID Application certificate not found in keychain"
          echo "Make sure you've exported the correct certificate from Keychain Access"
          echo "and updated the APPLE_CERTIFICATE secret with its base64 content."
          exit 1
        fi
        
        echo "SHA=$SHA" >> $GITHUB_OUTPUT
        echo "Found Developer ID Application certificate: $SHA"
        
        # Get the full name of the certificate for Tauri config
        CERT_NAME=$(security find-identity -v -p codesigning | 
                   grep "$SHA" | 
                   sed -E 's/.*"([^"]+)".*/\1/')
        echo "CERT_NAME=$CERT_NAME" >> $GITHUB_OUTPUT
        echo "Certificate name: $CERT_NAME"


    # Build the Tauri application
    - name: Build Tauri application
      run: |
        if [[ "${{ matrix.target_triple }}" == *musl* ]]; then
          cd edge_frontend && npm run tauri build -- --target ${{ matrix.target_triple }}
        else
          make tauri-build
        fi
      env:
        TAURI_SKIP_UPDATE_CHECK: 1
        APPLE_SIGNING_IDENTITY: ${{ steps.dev-id.outputs.CERT_NAME }}
        # Let Tauri handle notarization
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
      shell: bash

    # Build Python distribution (console-based edge client)
    - name: Build Python distribution
      if: contains(matrix.target_triple, 'linux')
      run: |
        # Clean dist directory of any non-Python artifacts first
        rm -f dist/todoforai-edge-sidecar*
        python -m pip install build
        python -m build --wheel --sdist
      shell: bash

    # Sign MSI installer using remote signing service  
    - name: Sign MSI installer
      if: matrix.os == 'windows-latest'
      continue-on-error: true
      id: sign-msi
      run: |
        $msiPath = Get-ChildItem -Path "edge_frontend/src-tauri/target/release/bundle/msi" -Filter "*.msi" | Select-Object -First 1 -ExpandProperty FullName
        if ($msiPath) {
          $originalSize = (Get-Item "$msiPath").Length
          $signedMsiPath = [System.IO.Path]::ChangeExtension($msiPath, ".signed.msi")
          Write-Host "Signing MSI installer: $msiPath ($(($originalSize / 1MB).ToString('F1')) MB)"
          
          & curl.exe -f -X POST -H "Authorization: Bearer $env:SIGNING_API_KEY" -F "file=@$msiPath" "$env:SIGNING_SERVICE_URL/sign" -o "$signedMsiPath"
          
          if ($LASTEXITCODE -eq 0 -and (Test-Path "$signedMsiPath")) {
            $signedSize = (Get-Item "$signedMsiPath").Length
            Write-Host "Downloaded signed MSI size: $(($signedSize / 1MB).ToString('F1')) MB"
            
            # Validate signed MSI is reasonable size
            if ($signedSize -gt ($originalSize * 0.9)) {
              Move-Item "$signedMsiPath" "$msiPath" -Force
              Write-Host "✅ Successfully signed MSI installer"
              echo "MSI_SIGNED=true" >> $GITHUB_OUTPUT
            } else {
              Write-Warning "⚠️ Signed MSI too small - likely an error response"
              Remove-Item "$signedMsiPath" -ErrorAction SilentlyContinue
              echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
            }
          } else {
            Write-Warning "⚠️ MSI signing failed (curl exit code: $LASTEXITCODE)"
            echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
          }
        } else {
          Write-Warning "MSI installer not found"
          echo "MSI_SIGNED=false" >> $GITHUB_OUTPUT
        }
      env:
        SIGNING_SERVICE_URL: ${{ secrets.SIGNING_SERVICE_URL }}
        SIGNING_API_KEY: ${{ secrets.SIGNING_API_KEY }}
      shell: powershell

    # Notarize and staple the macOS application using manual commands
    # Only run if Tauri's built-in notarization fails
    - name: Manual Notarize & staple macOS app
      if: startsWith(matrix.os, 'macos') && !contains(env.TAURI_BUILD_LOG, 'notarization complete')
      run: |
        # Create keychain profile for notarization
        echo "Creating notarization keychain profile"
        xcrun notarytool store-credentials "notary-profile" \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --team-id "${{ secrets.APPLE_TEAM_ID }}" \
          --password "${{ secrets.APPLE_APP_PASSWORD }}"
        
        # Find the DMG file
        DMG_PATH=$(find edge_frontend/src-tauri/target/release/bundle/dmg -name "*.dmg" | head -n 1)
        if [ -z "$DMG_PATH" ]; then
          echo "::error::DMG file not found"
          exit 1
        fi
        echo "Found DMG at: $DMG_PATH"
        
        # Submit for notarization and capture the submission ID using JSON output
        echo "Submitting for notarization..."
        SUBMISSION_JSON=$(xcrun notarytool submit "$DMG_PATH" \
          --keychain-profile "notary-profile" \
          --wait \
          --output-format json)
        
        echo "Notarization submission output:"
        echo "$SUBMISSION_JSON"
        
        # Extract the submission ID and status using jq
        SUBMISSION_ID=$(echo "$SUBMISSION_JSON" | jq -r '.id')
        STATUS=$(echo "$SUBMISSION_JSON" | jq -r '.status')
        
        echo "Notarization submission ID: $SUBMISSION_ID"
        echo "Notarization status: $STATUS"
        
        # Check if notarization was successful
        if [ "$STATUS" != "Accepted" ]; then
          echo "::error::Notarization failed with status: $STATUS"
          
          # Get detailed log for the submission
          echo "Fetching detailed notarization log..."
          xcrun notarytool log "$SUBMISSION_ID" \
            --keychain-profile "notary-profile" > notarization.log
          
          echo "::group::Notarization Log"
          cat notarization.log
          echo "::endgroup::"
          
          exit 1
        fi
        
        # Staple the notarization ticket to the DMG
        echo "Stapling notarization ticket..."
        xcrun stapler staple "$DMG_PATH"
        
        # Verify the stapling
        xcrun stapler validate "$DMG_PATH"
      shell: bash

    # Determine the Tauri app bundle path based on OS
    - name: Set Tauri bundle path
      id: bundle-path
      run: |
        if [ "${{ matrix.os }}" = "windows-latest" ]; then
          echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle/msi" >> $GITHUB_OUTPUT
          echo "BUNDLE_EXTENSION=msi" >> $GITHUB_OUTPUT
        else
          # For macOS, we'll collect both .app and .dmg
          echo "BUNDLE_PATH=edge_frontend/src-tauri/target/release/bundle" >> $GITHUB_OUTPUT
          echo "BUNDLE_EXTENSION=*" >> $GITHUB_OUTPUT
        fi
      shell: bash

    # Upload the Tauri application bundle as an artifact
    - name: Upload Tauri application bundle
      uses: actions/upload-artifact@v4
      with:
        name: todoforai-edge-${{ matrix.target_triple }}
        path: ${{ steps.bundle-path.outputs.BUNDLE_PATH }}

    # Upload Python distribution artifacts (only from one runner to avoid duplicates)
    - name: Upload Python distribution
      if: matrix.target_triple == 'x86_64-unknown-linux-gnu'
      uses: actions/upload-artifact@v4
      with:
        name: todoforai-edge-python-dist
        path: dist/

  # ─────────────────────────── Deployment ───────────────────────────
  deploy:
    needs: [build]
    uses: ./.github/workflows/deploy.yml
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/prod'
    secrets: inherit

  # New job for PyPI deployment - directly to production
  deploy-pypi:
    needs: [build]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v') || github.ref == 'refs/heads/prod'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.10'
    
    - name: Download Python distribution artifacts
      uses: actions/download-artifact@v4
      with:
        name: todoforai-edge-python-dist
        path: dist/
    
    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{ secrets.PYPI_API_TOKEN }}
        verbose: true
